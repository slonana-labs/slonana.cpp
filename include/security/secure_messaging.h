/**
 * @file secure_messaging.h
 * @brief Defines the interfaces and data structures for secure inter-node communication.
 *
 * This file contains the core components for ensuring secure communication
 * between validator nodes, including configuration structs, secure message
 * containers, and managers for TLS and message-level cryptography.
 */
#pragma once

#include "common/types.h"
#include <chrono>
#include <map>
#include <memory>
#include <mutex>
#include <openssl/evp.h>
#include <openssl/ssl.h>
#include <set>
#include <string>
#include <unordered_map>
#include <vector>

namespace slonana {
namespace security {

using namespace slonana::common;

/**
 * @brief Configuration for secure inter-node messaging.
 * @details Contains all cryptographic parameters, file paths, and settings
 * required to establish secure communication channels between validators.
 */
struct SecureMessagingConfig {
  /// @brief If true, enables TLS for all inter-node communication.
  bool enable_tls = true;
  /// @brief If true, requires mutual (two-way) TLS authentication between peers.
  bool require_mutual_auth = true;
  /// @brief Path to the node's TLS certificate file.
  std::string tls_cert_path;
  /// @brief Path to the node's TLS private key file.
  std::string tls_key_path;
  /// @brief Path to the Certificate Authority (CA) certificate for verifying peers.
  std::string ca_cert_path;
  /// @brief A string specifying the allowed TLS protocol versions (e.g., "TLSv1.3").
  std::string tls_protocols = "TLSv1.3";
  
  /// @brief If true, enables digital signatures for each message.
  bool enable_message_signing = true;
  /// @brief If true, enables end-to-end encryption for each message payload.
  bool enable_message_encryption = true;
  /// @brief Path to the node's Ed25519 signing key.
  std::string signing_key_path;
  /// @brief Directory containing the public keys of trusted peers for signature verification.
  std::string verification_keys_dir;
  
  /// @brief If true, enables nonce-based replay attack protection.
  bool enable_replay_protection = true;
  /// @brief The time-to-live for a message in seconds, after which it is considered invalid.
  uint64_t message_ttl_seconds = 300;
  /// @brief The maximum number of nonces to cache for replay detection.
  uint32_t nonce_cache_size = 10000;
  
  /// @brief The preferred TLS cipher suite for secure connections.
  std::string cipher_suite = "ECDHE-ECDSA-AES256-GCM-SHA384";
  /// @brief The timeout for the TLS handshake in milliseconds.
  uint32_t handshake_timeout_ms = 10000;
  /// @brief The interval in hours for TLS session renegotiation.
  uint32_t renegotiation_interval_hours = 24;
  /// @brief If true, requires cipher suites that provide Perfect Forward Secrecy (PFS).
  bool enable_perfect_forward_secrecy = true;
};

/**
 * @brief A container for encrypted and authenticated messages.
 * @details This struct wraps application messages with the necessary cryptographic
 * metadata for secure transmission, including encryption, signatures, and replay protection.
 */
struct SecureMessage {
  /// @brief The message content, encrypted using AES-GCM.
  std::vector<uint8_t> encrypted_payload;
  /// @brief An Ed25519 signature over the payload and metadata.
  std::vector<uint8_t> signature;
  /// @brief The sender's Ed25519 public key for signature verification.
  std::vector<uint8_t> sender_public_key;
  /// @brief The timestamp (in milliseconds since epoch) when the message was created.
  uint64_t timestamp_ms;
  /// @brief A unique cryptographic nonce to prevent replay attacks.
  uint64_t nonce;
  /// @brief The Initialization Vector (IV) used for AES-GCM encryption.
  std::vector<uint8_t> iv;
  /// @brief The authentication tag generated by AES-GCM, used for integrity checks.
  std::vector<uint8_t> auth_tag;
  /// @brief A string identifying the type of the application message.
  std::string message_type;
  
  std::vector<uint8_t> serialize() const;
  static Result<SecureMessage> deserialize(const std::vector<uint8_t>& data);
};

/**
 * @brief Manages SSL/TLS contexts for creating secure connections.
 * @details This class handles the loading of certificates and private keys,
 * configures TLS contexts for both client and server roles, and provides
 * methods for verifying peer certificates.
 */
class TlsContextManager {
public:
  explicit TlsContextManager(const SecureMessagingConfig& config);
  ~TlsContextManager();
  
  /**
   * @brief Initializes the TLS contexts by loading certificates and keys.
   * @return A Result indicating success or failure.
   */
  Result<bool> initialize();
  
  /**
   * @brief Gets the configured client-side TLS context.
   * @return A pointer to the client `SSL_CTX` object.
   */
  SSL_CTX* get_client_context() const { return client_ctx_; }
  
  /**
   * @brief Gets the configured server-side TLS context.
   * @return A pointer to the server `SSL_CTX` object.
   */
  SSL_CTX* get_server_context() const { return server_ctx_; }
  
  /**
   * @brief Verifies a peer's certificate during a TLS handshake.
   * @param ssl The SSL connection object.
   * @param expected_peer_id An optional expected peer identifier to check against.
   * @return True if the peer certificate is valid and trusted.
   */
  bool verify_peer_certificate(SSL* ssl, const std::string& expected_peer_id = "");
  
  /**
   * @brief Creates a new SSL connection object from a configured context.
   * @param is_client True to create a client-side SSL object, false for a server-side one.
   * @return A unique pointer to a new `SSL` object.
   */
  std::unique_ptr<SSL, void(*)(SSL*)> create_ssl_connection(bool is_client);
  
private:
  SecureMessagingConfig config_;
  SSL_CTX* client_ctx_;
  SSL_CTX* server_ctx_;
  
  bool load_certificates();
  bool setup_verification();
  static int verify_callback(int preverify_ok, X509_STORE_CTX* ctx);
};

/**
 * @brief Handles message-level cryptographic operations.
 * @details This class provides an API for end-to-end security, including
 * encrypting, decrypting, signing, and verifying messages, independent of the
 * underlying transport security (like TLS). It also manages replay protection.
 */
class MessageCrypto {
public:
  explicit MessageCrypto(const SecureMessagingConfig& config);
  ~MessageCrypto();
  
  /**
   * @brief Initializes the cryptographic context by loading signing keys and peer keys.
   * @return A Result indicating success or failure.
   */
  Result<bool> initialize();
  
  /**
   * @brief Encrypts and signs a plaintext message.
   * @param plaintext The raw data to protect.
   * @param message_type A string identifying the type of the message.
   * @param recipient_id The identifier of the recipient (currently unused, for future use).
   * @return A Result containing the protected `SecureMessage` on success, or an error.
   */
  Result<SecureMessage> protect_message(const std::vector<uint8_t>& plaintext,
                                       const std::string& message_type,
                                       const std::string& recipient_id = "");
  
  /**
   * @brief Decrypts and verifies a `SecureMessage`.
   * @param secure_msg The secure message to unprotect.
   * @param sender_id The identifier of the sender (currently unused, for future use).
   * @return A Result containing the original plaintext data on success, or an error.
   */
  Result<std::vector<uint8_t>> unprotect_message(const SecureMessage& secure_msg,
                                                 const std::string& sender_id = "");
  
  /**
   * @brief Verifies the digital signature of a message without decrypting it.
   * @param secure_msg The message whose signature is to be verified.
   * @param sender_public_key The public key of the sender.
   * @return True if the signature is valid, false otherwise.
   */
  bool verify_message_signature(const SecureMessage& secure_msg,
                               const std::vector<uint8_t>& sender_public_key);
  
  /**
   * @brief Validates that a message is fresh and not a replay.
   * @details Checks if the message timestamp is within the allowed TTL and if
   * its nonce has been seen before.
   * @param secure_msg The message to validate.
   * @return True if the message is fresh, false otherwise.
   */
  bool validate_message_freshness(const SecureMessage& secure_msg);
  
private:
  SecureMessagingConfig config_;
  EVP_PKEY* signing_key_;
  std::map<std::string, EVP_PKEY*> peer_keys_;
  std::unordered_map<uint64_t, std::chrono::steady_clock::time_point> used_nonces_;
  std::mutex nonce_mutex_;
  
  bool load_signing_key();
  bool load_peer_keys();
  uint64_t generate_nonce();
  bool is_nonce_used(uint64_t nonce);
  void add_used_nonce(uint64_t nonce);
  void cleanup_expired_nonces();
  
  bool derive_symmetric_key(std::vector<uint8_t>& key);
  Result<std::vector<uint8_t>> encrypt_aes_gcm(const std::vector<uint8_t>& plaintext, const std::vector<uint8_t>& key, const std::vector<uint8_t>& iv, std::vector<uint8_t>& auth_tag);
  Result<std::vector<uint8_t>> decrypt_aes_gcm(const std::vector<uint8_t>& ciphertext, const std::vector<uint8_t>& key, const std::vector<uint8_t>& iv, const std::vector<uint8_t>& auth_tag);
  Result<std::vector<uint8_t>> extract_public_key();
  std::vector<uint8_t> create_signature_data(const SecureMessage& msg);
  Result<std::vector<uint8_t>> sign_ed25519(const std::vector<uint8_t>& data);
  Result<bool> verify_ed25519(const std::vector<uint8_t>& data, const std::vector<uint8_t>& signature, const std::vector<uint8_t>& public_key);
};

/**
 * @brief A high-level manager for the entire secure messaging subsystem.
 * @details This class provides a unified interface for secure inter-node
 * communication, combining transport-level security (TLS) with message-level
 * cryptography (signing and encryption).
 */
class SecureMessaging {
public:
  explicit SecureMessaging(const SecureMessagingConfig& config);
  ~SecureMessaging();

  /**
   * @brief A collection of statistics about security operations.
   */
  struct SecurityStats {
    uint64_t messages_encrypted;
    uint64_t messages_decrypted;
    uint64_t signature_verifications;
    uint64_t tls_handshakes_completed;
    uint64_t replay_attacks_blocked;
    uint64_t invalid_signatures_rejected;
  };

  Result<bool> initialize();
  TlsContextManager& get_tls_manager() { return tls_manager_; }

  Result<std::vector<uint8_t>> prepare_outbound_message(const std::vector<uint8_t>& plaintext, const std::string& message_type, const std::string& recipient_id = "");
  Result<std::vector<uint8_t>> process_inbound_message(const std::vector<uint8_t>& encrypted_data, const std::string& sender_id = "");

  bool is_peer_trusted(const std::string& peer_id) const;
  void add_trusted_peer(const std::string& peer_id, const std::vector<uint8_t>& public_key);

  SecurityStats get_security_stats() const;
  
private:
  SecureMessagingConfig config_;
  TlsContextManager tls_manager_;
  MessageCrypto message_crypto_;
  mutable SecurityStats stats_;
  mutable std::mutex stats_mutex_;
  std::map<std::string, std::vector<uint8_t>> trusted_peers_;
  mutable std::mutex trusted_peers_mutex_;
  
  void update_stats(const std::string& metric, uint64_t count = 1);
};

/**
 * @brief A wrapper for a network connection that provides a secure channel using TLS.
 * @details This class transparently handles encryption and authentication for data
 * sent and received over an underlying network socket.
 */
class SecureChannel {
public:
  explicit SecureChannel(std::unique_ptr<SSL, void(*)(SSL*)> ssl_connection);
  ~SecureChannel();
  
  Result<size_t> send(const std::vector<uint8_t>& data);
  Result<std::vector<uint8_t>> receive(size_t max_bytes = 65536);
  
  bool is_secure() const;
  std::string get_peer_identity() const;
  std::string get_cipher_suite() const;
  
private:
  std::unique_ptr<SSL, void(*)(SSL*)> ssl_;
  bool authenticated_;
  
  bool complete_handshake();
};

} // namespace security
} // namespace slonana